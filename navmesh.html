<!--
File:page2.html
GUI Assignment: Creating Your First Web Page
Nick Haselton
9/4/24
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="stylesheet" href="css/thing.css">
		<meta charset="utf-8">
		<title>Nick's Portfolio</title>
	</head>
	<body>
		<h1>Navmesh</h1>
	<h2>What is a navmesh</h2>
	<p> In video games, you often have enemies that walk around the level. Inorder for them to know where they are allowed to walk and where objects/obstacles are located games typically use a navmesh. a navmesh is a set of connected convex shapes (typically triangles) that define the areas they can walk. From this navmesh, an algorithm such as A* is used to generate a path from 1 position on the map to another.</p>
	
	<figure>
	<img src="images/exampleNav.png" alt="Computer">
	<figcaption>Navigation Mesh From Unity.</figcaption>
	</figure>

	<h2> 1) Voxelize the scene  </h2>
	<p> First, i filter out all the geometry I don't want to count as navmesh data, this is things such as very steep slopes or roofs that nobody should be able to access. With that geometry I voxelize the scene. To do this, I get the bounds of the map, then make a 2d array of vertical spans. For each position on the x,z plane, i get a list of voxels that are touching scene geometry by doing an overlap request with the physics system. Each time it hits something, I add a vertical span containing the min & max Y values of that span. This way, If there's a block thats 10 units high, i can just store a single span with y0 = 0 and y1 = 10, rather than having to store each hit seperately. <a href="https://otik.uk.zcu.cz/bitstream/11025/10606/1/Saupin.pdf"> This paper </a> has more information about the voxelization process. </p> 
<pre><code>
for ( int i = 0; i &lt; width * depth; i++ ) {
	//XZ Plane
	int z = i / width;
	int x = i % width;

	//Y Plane, for spans
	for ( int n = 0; n &lt; height; n++){
		if ( Physics.Overlap( voxelbound ) ) {
			Span span;
			span.xz = Vec2(x,z);
			span.y0 = y;
			y++;

			//Find the end of this span
			while ( y &lt; height ){
				if ( !Physics.Overlap(voxelbound) ){
					span.y1 = y;
					break;
				}
				y++;
			}
		}
	}
}
</code></pre>
	<figure>
	<img src="images/nav1.png" alt="Computer">
	<figcaption>You then end up with spans of all the floors.</figcaption>
	</figure>

	<h2> 2) Group Spans into Regions </h2>
	<p> From these spans, you now want to group them by height. To do this, create a list of all the spans in the map, and a list of regions. regions should contain a list of spans that are all the same height. Then, foreach span in the list, run a flood fill that looks for other tiles of the same height. When you find one, remove it from the list and add it to the region. In the end, you should have a list of regions, that contain all the spans of the map </p>

	<pre><code>
		
struct Region{
	Span* first;
	int numSpans;
	Vec3 min,max;
}


for ( int i = 0; i < numspans; i++)
	list.push_back(spans[i]);

vector&lt;Region> regions;
		
while ( list.size > 0 ){
	Span* span = queue.front();
	queue.pop();

	Region region; //Region for this span

	Span* neighbors[8];
	int numNeighbors = GetNeighbors(span,neighbors); //Gets the amount of neighbors and adds them to neighbors

	for  ( int n = 0; n &lt; 8; n++ ){
		if( neighbors[i]->y == span->y ) {
			//Add to regions linked list
			neighbors[i]->next = reigon.spans;
			region.spans = neighbors[i];
		}
	}

	regions.push_back(region);
}
	</code></pre>
	<figure>
	<img src="images/nav2.png" alt="Computer">
		<figcaption>Each Region is a different color.</figcaption>
	</figure>

	<h2> 3) From Voxels to Polygons </h2>
	<p> We technically have enough data to allow characters to move, but there are a lot of voxels, which makes it slow and memory hungry. It would be better if we turned them into convex shapes and linked them togehter. A convex shape is a shpae where from any point in the shape, you can draw a line to any other point in the shape without leaving it's bounds. This is important, because when a character tries to find a path between 2 nodes, it has to be able to walk in a straight line from anywhere on 1 node to anywhere on the other node without leaving the graph. </p>

	<figure>
	<img src="images/convex.png" alt="Computer">
		<figcaption>Concave vs Convex.</figcaption>
	</figure>

	<figure>
	<img src="images/goodnav.png" alt="Computer">
		<figcaption>Why Concave shapes are important.</figcaption>
	</figure>

	<p> Not only do our regions have to be convex, but we also have to ensure that if we combine with a neighboring node, it still forms a convex shape. If we naively turn our regions into polygons, we end up with the T shape in the 2nd figure, which would allow a path that walks off the map. What we need to do is take other regions into account. Typically games will triangulate the navmesh, and there are good solutions for this, such as <a href="https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf#page=17&zoom=100,96,182"> ear clipping </a> or constrained <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">  delaunay triangulation </a>, but these have drawbacks. Ear clipping starts to fall apart when you have many holes in the map, and constrained delaunay is much more complicated to implement, and since my project uses simple geometry I chose to create my own algorithm.   </p>

	<p> Voxel games, such as minecraft employ a technique called greedy meshing, which invovles going over all the voxels in a scene and grouping them into easy to render polygons for the GPU. I had the idea to try and take this but force it to only give me meshes that are convex when connected to each other, and to do this I realized I could just check if the corners of a voxel change. If a voxel goes from having 4 neighbors to 3 neighbors, then there is a corner somewhere and it might not be able to connect to other polygons. Instead of calculating these corners every single time we iterate ovre a voxel, we can store it as a single byte. There are 8 neighbors, and if we say each neighbor is a single bit then it can be stored in a byte., If we want to compare the neighbor values of 2 voxels, you just check if the 2 bytes equal. It allows allows for bitwise operators to check if 2 bytes share certain neighbors or don't have certain neighbors.</p>
	<figure>

	<img src="images/corners.png" class="resize">
		<figcaption>The Corner bit values.</figcaption>
	</figure>

	<h1>I'll finish this later this should be enough text for homework 1</h1>


	</body>
</html>